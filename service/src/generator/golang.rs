//! Go code generator for `LinkML` schemas
//!
//! This generator creates Go structs, interfaces, and validation code from `LinkML` schemas.

use super::traits::{Generator, GeneratorError};
use crate::generator::GeneratorResult;
use convert_case::{Case, Casing};
use linkml_core::prelude::*;
use std::collections::{BTreeMap, HashSet};
use std::fmt::Write;

/// Go code generator
pub struct GoGenerator {
    /// Package name for generated code
    package_name: String,
    /// Whether to generate validation methods
    generate_validation: bool,
    /// Whether to generate `JSON` tags
    generate_json_tags: bool,
    /// Whether to generate interfaces
    generate_interfaces: bool,
    /// Generator options
    options: super::traits::GeneratorOptions,
}

impl GoGenerator {
    /// Convert `fmt::Error` to `GeneratorError`
    fn fmt_error_to_generator_error(e: std::fmt::Error) -> GeneratorError {
        GeneratorError::Io(std::io::Error::other(e))
    }

    /// Create a new Go generator
    #[must_use]
    pub fn new() -> Self {
        Self {
            package_name: "linkml".to_string(),
            generate_validation: true,
            generate_json_tags: true,
            generate_interfaces: true,
            options: super::traits::GeneratorOptions::default(),
        }
    }

    /// Create generator with options
    #[must_use]
    pub fn with_options(options: super::traits::GeneratorOptions) -> Self {
        let mut generator = Self::new();
        generator.options = options;
        generator
    }

    /// Set the package name
    #[must_use]
    pub fn with_package(mut self, package: String) -> Self {
        self.package_name = package;
        self
    }

    /// Configure validation generation
    #[must_use]
    pub fn with_validation(mut self, enabled: bool) -> Self {
        self.generate_validation = enabled;
        self
    }

    /// Configure `JSON` tag generation
    #[must_use]
    pub fn with_json_tags(mut self, enabled: bool) -> Self {
        self.generate_json_tags = enabled;
        self
    }

    /// Configure interface generation
    #[must_use]
    pub fn with_interfaces(mut self, enabled: bool) -> Self {
        self.generate_interfaces = enabled;
        self
    }

    /// Generate the package header
    fn generate_header(&self, schema: &SchemaDefinition) -> GeneratorResult<String> {
        let mut output = String::new();

        writeln!(
            &mut output,
            "// Code generated by LinkML Go Generator. DO NOT EDIT."
        )
        .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;
        writeln!(&mut output, "package {}", self.package_name)
            .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;

        if let Some(description) = &schema.description {
            writeln!(&mut output, "// {description}")
                .map_err(Self::fmt_error_to_generator_error)?;
            writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;
        }

        Ok(output)
    }

    /// Generate imports
    fn generate_imports(schema: &SchemaDefinition) -> GeneratorResult<String> {
        let mut output = String::new();
        let mut imports = HashSet::new();

        // Always need fmt for errors
        imports.insert("fmt");

        // Check if we need time package
        for slot in schema.slots.values() {
            if matches!(slot.range.as_deref(), Some("date" | "datetime")) {
                imports.insert("time");
                break;
            }
        }

        // Check if we need regexp
        for slot in schema.slots.values() {
            if slot.pattern.is_some() {
                imports.insert("regexp");
                break;
            }
        }

        if !imports.is_empty() {
            writeln!(&mut output, "import (").map_err(Self::fmt_error_to_generator_error)?;
            for import in imports {
                writeln!(&mut output, "\t\"{import}\"")
                    .map_err(Self::fmt_error_to_generator_error)?;
            }
            writeln!(&mut output, ")").map_err(Self::fmt_error_to_generator_error)?;
            writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;
        }

        Ok(output)
    }

    /// Generate type definitions
    fn generate_types(&self, schema: &SchemaDefinition) -> GeneratorResult<String> {
        let mut output = String::new();

        // Generate custom types
        for (type_name, type_def) in &schema.types {
            let go_name = Self::to_go_type_name(type_name);
            let base_type = Self::map_type(type_def.base_type.as_deref().unwrap_or("string"));

            writeln!(
                &mut output,
                "// {} represents {}",
                go_name,
                type_def.description.as_deref().unwrap_or(type_name)
            )
            .map_err(Self::fmt_error_to_generator_error)?;
            writeln!(&mut output, "type {go_name} {base_type}")
                .map_err(Self::fmt_error_to_generator_error)?;
            writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;

            // Generate validation if pattern exists
            if let Some(pattern) = &type_def.pattern
                && self.generate_validation
            {
                Self::generate_type_validation(&mut output, &go_name, pattern)?;
            }
        }

        Ok(output)
    }

    /// Generate enums
    fn generate_enums(&self, schema: &SchemaDefinition) -> GeneratorResult<String> {
        let mut output = String::new();

        for (enum_name, enum_def) in &schema.enums {
            let go_name = Self::to_go_type_name(enum_name);

            writeln!(
                &mut output,
                "// {} represents {}",
                go_name,
                enum_def.description.as_deref().unwrap_or(enum_name)
            )
            .map_err(Self::fmt_error_to_generator_error)?;
            writeln!(&mut output, "type {go_name} string")
                .map_err(Self::fmt_error_to_generator_error)?;
            writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;

            // Generate constants
            writeln!(&mut output, "const (").map_err(Self::fmt_error_to_generator_error)?;
            for (i, pv) in enum_def.permissible_values.iter().enumerate() {
                let (value, description) = match pv {
                    linkml_core::types::PermissibleValue::Simple(s) => (s.as_str(), None),
                    linkml_core::types::PermissibleValue::Complex {
                        text, description, ..
                    } => (text.as_str(), description.as_ref()),
                };

                let const_name = format!("{}{}", go_name, Self::to_go_const_name(value));

                if let Some(desc) = description {
                    writeln!(&mut output, "\t// {const_name} - {desc}")
                        .map_err(Self::fmt_error_to_generator_error)?;
                }

                writeln!(&mut output, "\t{const_name} {go_name} = \"{value}\"")
                    .map_err(Self::fmt_error_to_generator_error)?;

                if i < enum_def.permissible_values.len() - 1 {
                    writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;
                }
            }
            writeln!(&mut output, ")").map_err(Self::fmt_error_to_generator_error)?;
            writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;

            // Generate validation
            if self.generate_validation {
                Self::generate_enum_validation(
                    &mut output,
                    &go_name,
                    &enum_def.permissible_values,
                )?;
            }
        }

        Ok(output)
    }

    /// Generate interfaces
    fn generate_interfaces(&self, schema: &SchemaDefinition) -> GeneratorResult<String> {
        let mut output = String::new();

        if !self.generate_interfaces {
            return Ok(output);
        }

        // Find abstract classes to turn into interfaces
        for (class_name, class_def) in &schema.classes {
            if class_def.abstract_.unwrap_or(false) {
                let interface_name = format!("{}Interface", Self::to_go_type_name(class_name));

                writeln!(
                    &mut output,
                    "// {interface_name} defines the interface for {class_name}"
                )
                .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(&mut output, "type {interface_name} interface {{")
                    .map_err(Self::fmt_error_to_generator_error)?;

                // Add getter methods for all slots
                let slots = self.collect_class_slots(class_name, class_def, schema);
                for (slot_name, slot_def) in slots {
                    let method_name = format!("Get{}", Self::to_go_type_name(&slot_name));
                    let return_type = Self::get_go_type(&slot_def, schema);
                    writeln!(&mut output, "\t{method_name}() {return_type}")
                        .map_err(Self::fmt_error_to_generator_error)?;
                }

                if self.generate_validation {
                    writeln!(&mut output, "\tValidate() error")
                        .map_err(Self::fmt_error_to_generator_error)?;
                }

                writeln!(&mut output, "}}").map_err(Self::fmt_error_to_generator_error)?;
                writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;
            }
        }

        Ok(output)
    }

    /// Generate structs
    fn generate_structs(&self, schema: &SchemaDefinition) -> GeneratorResult<String> {
        let mut output = String::new();

        for (class_name, class_def) in &schema.classes {
            if class_def.abstract_.unwrap_or(false) && self.generate_interfaces {
                continue; // Skip abstract classes if we're generating interfaces
            }

            let struct_name = Self::to_go_type_name(class_name);

            // Generate struct comment
            if let Some(description) = &class_def.description {
                writeln!(&mut output, "// {struct_name} represents {description}")
                    .map_err(Self::fmt_error_to_generator_error)?;
            } else {
                writeln!(
                    &mut output,
                    "// {struct_name} represents a {class_name} entity"
                )
                .map_err(Self::fmt_error_to_generator_error)?;
            }

            // Generate struct
            writeln!(&mut output, "type {struct_name} struct {{")
                .map_err(Self::fmt_error_to_generator_error)?;

            // Collect all slots (inherited and direct)
            let slots = self.collect_class_slots(class_name, class_def, schema);

            for (slot_name, slot_def) in slots {
                let field_name = Self::to_go_field_name(&slot_name);
                let field_type = Self::get_go_type(&slot_def, schema);

                write!(&mut output, "\t{field_name} {field_type}")
                    .map_err(Self::fmt_error_to_generator_error)?;

                // Add JSON tag if enabled
                if self.generate_json_tags {
                    let json_name = slot_name.to_case(Case::Camel);
                    let omitempty = if slot_def.required.unwrap_or(false) {
                        ""
                    } else {
                        ",omitempty"
                    };
                    write!(&mut output, " `json:\"{json_name}{omitempty}\"`")
                        .map_err(Self::fmt_error_to_generator_error)?;
                }

                // Add comment
                if let Some(description) = &slot_def.description {
                    write!(&mut output, " // {description}")
                        .map_err(Self::fmt_error_to_generator_error)?;
                }

                writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;
            }

            writeln!(&mut output, "}}").map_err(Self::fmt_error_to_generator_error)?;
            writeln!(&mut output).map_err(Self::fmt_error_to_generator_error)?;

            // Generate validation method
            if self.generate_validation {
                self.generate_struct_validation(
                    &mut output,
                    &struct_name,
                    class_name,
                    class_def,
                    schema,
                )?;
            }

            // Generate interface methods if needed
            if self.generate_interfaces
                && let Some(parent) = &class_def.is_a
                && let Some(parent_class) = schema.classes.get(parent)
                && parent_class.abstract_.unwrap_or(false)
            {
                self.generate_interface_methods(
                    &mut output,
                    &struct_name,
                    class_name,
                    class_def,
                    schema,
                )?;
            }
        }

        Ok(output)
    }

    /// Generate validation for a custom type
    fn generate_type_validation(
        output: &mut String,
        type_name: &str,
        pattern: &str,
    ) -> GeneratorResult<()> {
        writeln!(
            output,
            "var {}Regex = regexp.MustCompile(`{}`)",
            type_name.to_case(Case::Camel),
            pattern
        )
        .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output).map_err(Self::fmt_error_to_generator_error)?;

        writeln!(
            output,
            "// Validate checks if the {type_name} value is valid"
        )
        .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "func (t {type_name}) Validate() error {{")
            .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(
            output,
            "\tif !{}Regex.MatchString(string(t)) {{",
            type_name.to_case(Case::Camel)
        )
        .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(
            output,
            "\t\treturn fmt.Errorf(\"invalid {type_name}: %s\", t)"
        )
        .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "\t}}").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "\treturn nil").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "}}").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output).map_err(Self::fmt_error_to_generator_error)?;
        Ok(())
    }

    /// Generate validation for an enum
    fn generate_enum_validation(
        output: &mut String,
        enum_name: &str,
        values: &[linkml_core::types::PermissibleValue],
    ) -> GeneratorResult<()> {
        writeln!(
            output,
            "// Validate checks if the {enum_name} value is valid"
        )
        .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "func (e {enum_name}) Validate() error {{")
            .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "\tswitch e {{").map_err(Self::fmt_error_to_generator_error)?;

        for pv in values {
            let value = match pv {
                linkml_core::types::PermissibleValue::Simple(s)
                | linkml_core::types::PermissibleValue::Complex { text: s, .. } => s.as_str(),
            };
            let const_name = format!("{}{}", enum_name, Self::to_go_const_name(value));
            writeln!(output, "\tcase {const_name}:").map_err(Self::fmt_error_to_generator_error)?;
        }

        writeln!(output, "\t\treturn nil").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "\tdefault:").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(
            output,
            "\t\treturn fmt.Errorf(\"invalid {enum_name}: %s\", e)"
        )
        .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "\t}}").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "}}").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output).map_err(Self::fmt_error_to_generator_error)?;
        Ok(())
    }

    /// Generate validation method for a struct
    fn generate_struct_validation(
        &self,
        output: &mut String,
        struct_name: &str,
        class_name: &str,
        class_def: &ClassDefinition,
        schema: &SchemaDefinition,
    ) -> GeneratorResult<()> {
        writeln!(output, "// Validate checks if the {struct_name} is valid")
            .map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "func (s *{struct_name}) Validate() error {{")
            .map_err(Self::fmt_error_to_generator_error)?;

        let slots = self.collect_class_slots(class_name, class_def, schema);

        for (slot_name, slot_def) in slots {
            let field_name = Self::to_go_field_name(&slot_name);

            // Required field validation
            if slot_def.required.unwrap_or(false) {
                match slot_def.range.as_deref() {
                    Some("string") => {
                        writeln!(output, "\tif s.{field_name} == \"\" {{")
                            .map_err(Self::fmt_error_to_generator_error)?;
                        writeln!(output, "\t\treturn fmt.Errorf(\"{slot_name} is required\")")
                            .map_err(Self::fmt_error_to_generator_error)?;
                        writeln!(output, "\t}}").map_err(Self::fmt_error_to_generator_error)?;
                    }
                    _ if !slot_def.multivalued.unwrap_or(false) => {
                        // For non-multivalued non-string types, we'd need nil checks
                        // but Go doesn't have nil for non-pointer types by default
                    }
                    _ => {}
                }
            }

            // Pattern validation
            if let Some(pattern) = &slot_def.pattern {
                writeln!(output, "\tif s.{field_name} != \"\" {{")
                    .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(
                    output,
                    "\t\tmatched, _ := regexp.MatchString(`{pattern}`, s.{field_name})"
                )
                .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(output, "\t\tif !matched {{")
                    .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(
                    output,
                    "\t\t\treturn fmt.Errorf(\"{slot_name} does not match pattern\")"
                )
                .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(output, "\t\t}}").map_err(Self::fmt_error_to_generator_error)?;
                writeln!(output, "\t}}").map_err(Self::fmt_error_to_generator_error)?;
            }

            // Range validation for numbers
            if let Some(min) = &slot_def.minimum_value {
                writeln!(output, "\tif s.{field_name} < {min} {{")
                    .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(
                    output,
                    "\t\treturn fmt.Errorf(\"{slot_name} must be >= {min}\")"
                )
                .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(output, "\t}}").map_err(Self::fmt_error_to_generator_error)?;
            }

            if let Some(max) = &slot_def.maximum_value {
                writeln!(output, "\tif s.{field_name} > {max} {{")
                    .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(
                    output,
                    "\t\treturn fmt.Errorf(\"{slot_name} must be <= {max}\")"
                )
                .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(output, "\t}}").map_err(Self::fmt_error_to_generator_error)?;
            }

            // Enum validation
            if let Some(_enum_name) = Self::get_enum_type(&slot_def, schema) {
                writeln!(
                    output,
                    "\tif err := s.{field_name}.Validate(); err != nil {{"
                )
                .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(
                    output,
                    "\t\treturn fmt.Errorf(\"{slot_name} validation failed: %w\", err)"
                )
                .map_err(Self::fmt_error_to_generator_error)?;
                writeln!(output, "\t}}").map_err(Self::fmt_error_to_generator_error)?;
            }
        }

        writeln!(output, "\treturn nil").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output, "}}").map_err(Self::fmt_error_to_generator_error)?;
        writeln!(output).map_err(Self::fmt_error_to_generator_error)?;
        Ok(())
    }

    /// Generate interface methods
    fn generate_interface_methods(
        &self,
        output: &mut String,
        struct_name: &str,
        class_name: &str,
        class_def: &ClassDefinition,
        schema: &SchemaDefinition,
    ) -> GeneratorResult<()> {
        let slots = self.collect_class_slots(class_name, class_def, schema);

        for (slot_name, slot_def) in slots {
            let method_name = format!("Get{}", Self::to_go_type_name(&slot_name));
            let field_name = Self::to_go_field_name(&slot_name);
            let return_type = Self::get_go_type(&slot_def, schema);

            writeln!(output, "// {method_name} returns the {slot_name} value")
                .map_err(Self::fmt_error_to_generator_error)?;
            writeln!(
                output,
                "func (s *{struct_name}) {method_name}() {return_type} {{"
            )
            .map_err(Self::fmt_error_to_generator_error)?;
            writeln!(output, "\treturn s.{field_name}")
                .map_err(Self::fmt_error_to_generator_error)?;
            writeln!(output, "}}").map_err(Self::fmt_error_to_generator_error)?;
            writeln!(output).map_err(Self::fmt_error_to_generator_error)?;
        }
        Ok(())
    }

    /// Convert to Go type name (`PascalCase`)
    fn to_go_type_name(name: &str) -> String {
        name.to_case(Case::Pascal)
    }

    /// Convert to Go field name (`PascalCase` for exported fields)
    fn to_go_field_name(name: &str) -> String {
        name.to_case(Case::Pascal)
    }

    /// Convert to Go constant name (`PascalCase` for Go enum constants)
    fn to_go_const_name(name: &str) -> String {
        // For enum values that are already uppercase (like "ACTIVE"), keep them as-is
        // For other cases, convert to PascalCase (Go convention for exported constants)
        if name.chars().all(|c| c.is_uppercase() || !c.is_alphabetic()) {
            // Already all uppercase, keep as-is (e.g., "ACTIVE" stays "ACTIVE")
            name.to_string()
        } else {
            // Convert to PascalCase for Go enum constants
            name.to_case(Case::Pascal)
        }
    }

    /// Map `LinkML` type to Go type
    fn map_type(linkml_type: &str) -> &'static str {
        match linkml_type {
            "string" | "str" | "uri" | "uriorcurie" | "curie" | "ncname" => "string",
            "integer" | "int" => "int64",
            "float" | "double" | "decimal" => "float64",
            "boolean" | "bool" => "bool",
            "date" | "datetime" => "time.Time",
            _ => "interface{}",
        }
    }

    /// Get the Go type for a slot
    fn get_go_type(slot: &SlotDefinition, schema: &SchemaDefinition) -> String {
        let base_type = if let Some(range) = &slot.range {
            // Check if it's an enum
            if schema.enums.contains_key(range) || schema.types.contains_key(range) {
                Self::to_go_type_name(range)
            } else if schema.classes.contains_key(range) {
                format!("*{}", Self::to_go_type_name(range))
            } else {
                Self::map_type(range).to_string()
            }
        } else {
            "interface{}".to_string()
        };

        if slot.multivalued.unwrap_or(false) {
            format!("[]{base_type}")
        } else {
            base_type
        }
    }

    /// Check if a slot references an enum
    fn get_enum_type(slot: &SlotDefinition, schema: &SchemaDefinition) -> Option<String> {
        if let Some(range) = &slot.range
            && schema.enums.contains_key(range)
        {
            return Some(Self::to_go_type_name(range));
        }
        None
    }

    /// Collect all slots for a class including inherited
    fn collect_class_slots(
        &self,
        _class_name: &str,
        class_def: &ClassDefinition,
        schema: &SchemaDefinition,
    ) -> Vec<(String, SlotDefinition)> {
        let mut slots = BTreeMap::new();

        // Get inherited slots
        if let Some(parent) = &class_def.is_a
            && let Some(parent_class) = schema.classes.get(parent)
        {
            let parent_slots = self.collect_class_slots(parent, parent_class, schema);
            for (name, slot) in parent_slots {
                slots.insert(name, slot);
            }
        }

        // Add direct slots
        for slot_name in &class_def.slots {
            if let Some(slot_def) = schema.slots.get(slot_name) {
                slots.insert(slot_name.clone(), slot_def.clone());
            }
        }

        // Add attributes
        for (attr_name, attr_def) in &class_def.attributes {
            slots.insert(attr_name.clone(), attr_def.clone());
        }

        // Apply slot usage overrides
        for (slot_name, slot_usage) in &class_def.slot_usage {
            if let Some(slot) = slots.get_mut(slot_name) {
                if let Some(required) = slot_usage.required {
                    slot.required = Some(required);
                }
                if let Some(ref range) = slot_usage.range {
                    slot.range = Some(range.clone());
                }
            }
        }

        slots.into_iter().collect()
    }
}

impl Default for GoGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl Generator for GoGenerator {
    fn name(&self) -> &'static str {
        "golang"
    }

    fn description(&self) -> &'static str {
        "Generate Go code from LinkML schemas"
    }

    fn validate_schema(&self, schema: &SchemaDefinition) -> std::result::Result<(), LinkMLError> {
        // Validate schema has required fields for Go generation
        if schema.name.is_empty() {
            return Err(LinkMLError::SchemaValidationError {
                message: "Schema must have a name for Go generation".to_string(),
                element: Some("schema.name".to_string()),
            });
        }

        // Validate Go-specific requirements
        for (class_name, _class_def) in &schema.classes {
            // Go identifiers must start with a letter
            if let Some(first) = class_name.chars().next()
                && !first.is_ascii_alphabetic()
            {
                return Err(LinkMLError::SchemaValidationError {
                    message: format!(
                        "Class name '{class_name}' is not valid for Go: must start with a letter"
                    ),
                    element: Some(format!("class.{class_name}")),
                });
            }

            // Check for Go reserved words
            if matches!(
                class_name.as_str(),
                "break"
                    | "default"
                    | "func"
                    | "interface"
                    | "select"
                    | "case"
                    | "defer"
                    | "go"
                    | "map"
                    | "struct"
                    | "chan"
                    | "else"
                    | "goto"
                    | "package"
                    | "switch"
                    | "const"
                    | "fallthrough"
                    | "if"
                    | "range"
                    | "type"
                    | "continue"
                    | "for"
                    | "import"
                    | "return"
                    | "var"
            ) {
                return Err(LinkMLError::SchemaValidationError {
                    message: format!("Class name '{class_name}' is a Go reserved keyword"),
                    element: Some(format!("class.{class_name}")),
                });
            }
        }

        // Validate slot names for Go compatibility
        for (slot_name, _slot_def) in &schema.slots {
            if let Some(first) = slot_name.chars().next()
                && !first.is_ascii_alphabetic()
                && first != '_'
            {
                return Err(LinkMLError::SchemaValidationError {
                    message: format!(
                        "Slot name '{slot_name}' is not valid for Go: must start with letter or underscore"
                    ),
                    element: Some(format!("slot.{slot_name}")),
                });
            }
        }

        Ok(())
    }

    fn generate(&self, schema: &SchemaDefinition) -> std::result::Result<String, LinkMLError> {
        let mut content = String::new();

        // Generate sections
        content.push_str(
            &self
                .generate_header(schema)
                .map_err(|e| LinkMLError::service(format!("Go generation error: {e}")))?,
        );
        content.push_str(
            &Self::generate_imports(schema)
                .map_err(|e| LinkMLError::service(format!("Go generation error: {e}")))?,
        );
        content.push_str(
            &self
                .generate_types(schema)
                .map_err(|e| LinkMLError::service(format!("Go generation error: {e}")))?,
        );
        content.push_str(
            &self
                .generate_enums(schema)
                .map_err(|e| LinkMLError::service(format!("Go generation error: {e}")))?,
        );
        content.push_str(
            &self
                .generate_interfaces(schema)
                .map_err(|e| LinkMLError::service(format!("Go generation error: {e}")))?,
        );
        content.push_str(
            &self
                .generate_structs(schema)
                .map_err(|e| LinkMLError::service(format!("Go generation error: {e}")))?,
        );

        Ok(content)
    }

    fn get_file_extension(&self) -> &'static str {
        "go"
    }

    fn get_default_filename(&self) -> &'static str {
        "schema"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use linkml_core::types::{ClassDefinition, SchemaDefinition, SlotDefinition};

    fn create_test_schema() -> SchemaDefinition {
        let mut schema = SchemaDefinition::default();
        schema.name = "TestSchema".to_string();

        // Add a class
        let mut person_class = ClassDefinition::default();
        person_class.description = Some("A person entity".to_string());
        person_class.slots = vec!["name".to_string(), "age".to_string()];
        schema.classes.insert("Person".to_string(), person_class);

        // Add slots
        let mut name_slot = SlotDefinition::default();
        name_slot.range = Some("string".to_string());
        name_slot.required = Some(true);
        schema.slots.insert("name".to_string(), name_slot);

        let mut age_slot = SlotDefinition::default();
        age_slot.range = Some("integer".to_string());
        age_slot.minimum_value = Some(serde_json::json!(0));
        age_slot.maximum_value = Some(serde_json::json!(150));
        schema.slots.insert("age".to_string(), age_slot);

        // Add an enum
        let mut status_enum = EnumDefinition::default();
        status_enum.description = Some("Status values".to_string());
        status_enum.permissible_values = vec![
            linkml_core::types::PermissibleValue::Complex {
                text: "ACTIVE".to_string(),
                description: Some("Active status".to_string()),
                meaning: None,
            },
            linkml_core::types::PermissibleValue::Simple("INACTIVE".to_string()),
        ];
        schema.enums.insert("Status".to_string(), status_enum);

        schema
    }

    #[test]
    fn test_go_generation() -> anyhow::Result<()> {
        let schema = create_test_schema();
        let generator = GoGenerator::new();

        let content = generator
            .generate(&schema)
            .expect("should generate Go code: {}");

        // Check content
        assert!(content.contains("package linkml"));
        assert!(content.contains("type Person struct"));
        assert!(content.contains("Name string"));
        assert!(content.contains("Age int64"));
        assert!(content.contains("type Status string"));
        assert!(content.contains("StatusACTIVE Status = \"ACTIVE\""));
        assert!(content.contains("func (s *Person) Validate() error"));
        Ok(())
    }

    #[test]
    fn test_type_mapping() {
        assert_eq!(GoGenerator::map_type("string"), "string");
        assert_eq!(GoGenerator::map_type("integer"), "int64");
        assert_eq!(GoGenerator::map_type("float"), "float64");
        assert_eq!(GoGenerator::map_type("boolean"), "bool");
        assert_eq!(GoGenerator::map_type("date"), "time.Time");
        assert_eq!(GoGenerator::map_type("unknown"), "interface{}");
    }

    #[test]
    fn test_name_conversion() {
        assert_eq!(GoGenerator::to_go_type_name("my_class"), "MyClass");
        assert_eq!(GoGenerator::to_go_field_name("my_field"), "MyField");
        assert_eq!(GoGenerator::to_go_const_name("my_value"), "MyValue");
    }
}

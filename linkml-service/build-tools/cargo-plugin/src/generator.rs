//! Code generation functionality

use anyhow::{Context, Result};
use colored::Colorize;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Generation options
pub struct GenerateOptions {
    pub serde: bool,
    pub debug: bool,
    pub clone: bool,
    pub validate_first: bool,
    pub verbose: bool,
}

/// Generate Rust code from LinkML schemas
pub async fn generate_code(
    schema_dir: &Path,
    output_dir: &Path,
    include: &[String],
    exclude: &[String],
    options: GenerateOptions,
) -> Result<()> {
    let schemas = crate::find_schemas(schema_dir, include, exclude)?;

    if schemas.is_empty() {
        println!("{} No LinkML schemas found", "Info:".blue());
        return Ok(());
    }

    // Create output directory
    std::fs::create_dir_all(output_dir)?;

    // Create mod.rs
    let mod_path = output_dir.join("mod.rs");
    let mut mod_content = String::from("//! Generated LinkML types
//!
//! This file was automatically generated by cargo-linkml.
//! Do not edit manually.

");

    println!("Generating Rust code for {} schema(s)...", schemas.len());

    let mut success_count = 0;
    let mut modules = Vec::new();

    for schema in &schemas {
        let relative_path = schema.strip_prefix(schema_dir).unwrap_or(schema);

        // Validate first if requested
        if options.validate_first {
            match validate_schema(schema).await {
                Ok(_) => {}
                Err(e) => {
                    eprintln!("{} Validation failed for {}: {}", "✗".red(), relative_path.display(), e);
                    continue;
                }
            }
        }

        match generate_from_schema(schema, output_dir, &options).await {
            Ok(module_name) => {
                println!("{} Generated: {} → {}.rs", "✓".green(), relative_path.display(), module_name);
                modules.push(module_name);
                success_count += 1;
            }
            Err(e) => {
                eprintln!("{} Failed to generate from {}: {}", "✗".red(), relative_path.display(), e);
            }
        }
    }

    // Write mod.rs
    for module in &modules {
        mod_content.push_str(&format!("pub mod {};
", module));
    }

    if !modules.is_empty() {
        mod_content.push_str("
// Re-exports
");
        for module in &modules {
            mod_content.push_str(&format!("pub use {}::*;
", module));
        }
    }

    std::fs::write(&mod_path, mod_content)?;

    // Summary
    println!("
{} Generated {}/{} schemas successfully",
             "Summary:".bold(),
             success_count,
             schemas.len());
    println!("Output directory: {}", output_dir.display());

    // Run rustfmt on generated code
    if success_count > 0 {
        println!("
Formatting generated code...");
        format_generated_code(output_dir)?;
    }

    Ok(())
}

/// Validate a schema before generation
async fn validate_schema(schema: &Path) -> Result<()> {
    let mut cmd = Command::new("linkml");
    cmd.arg("validate");
    cmd.arg(schema);

    let output = cmd.output()?;

    if !output.status.success() {
        let error = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("{}", error.trim());
    }

    Ok(())
}

/// Generate code from a single schema
async fn generate_from_schema(
    schema: &Path,
    output_dir: &Path,
    options: &GenerateOptions,
) -> Result<String> {
    // Determine module name from schema file
    let stem = schema.file_stem()
        .and_then(|s| s.to_str())
        .context("Invalid schema filename")?;

    let module_name = stem.replace('-', "_").replace('.', "_").to_lowercase();
    let output_file = output_dir.join(format!("{}.rs", module_name));

    // Generate using LinkML
    let mut cmd = Command::new("linkml");
    cmd.arg("generate");
    cmd.arg("-t").arg("rust");
    cmd.arg("-o").arg(&output_file);

    // Add derive options
    let mut derives = vec![];
    if options.serde {
        derives.push("Serialize");
        derives.push("Deserialize");
    }
    if options.debug {
        derives.push("Debug");
    }
    if options.clone {
        derives.push("Clone");
    }

    if !derives.is_empty() {
        cmd.arg("--derives").arg(derives.join(","));
    }

    cmd.arg(schema);

    let output = cmd.output()?;

    if !output.status.success() {
        let error = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Generation failed: {}", error);
    }

    // Post-process the generated file
    post_process_generated_code(&output_file, options)?;

    Ok(module_name)
}

/// Post-process generated Rust code
fn post_process_generated_code(file: &Path, options: &GenerateOptions) -> Result<()> {
    let content = std::fs::read_to_string(file)?;
    let mut lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();

    // Add file header if not present
    if !lines.is_empty() && !lines[0].starts_with("//!") {
        lines.insert(0, format!("//! Generated from LinkML schema"));
        lines.insert(1, format!("//!"));
        lines.insert(2, format!("//! This file was automatically generated by cargo-linkml."));
        lines.insert(3, format!("//! Do not edit manually."));
        lines.insert(4, String::new());
    }

    // Add imports if using serde
    if options.serde {
        let mut found_serde = false;
        for line in &lines {
            if line.contains("use serde") {
                found_serde = true;
                break;
            }
        }

        if !found_serde {
            // Find where to insert (after doc comments)
            let mut insert_pos = 0;
            for (i, line) in lines.iter().enumerate() {
                if !line.starts_with("//") && !line.is_empty() {
                    insert_pos = i;
                    break;
                }
            }

            lines.insert(insert_pos, String::from("use serde::{Serialize, Deserialize};"));
            lines.insert(insert_pos + 1, String::new());
        }
    }

    // Write back
    let content = lines.join("
");
    std::fs::write(file, content)?;

    Ok(())
}

/// Format generated code using rustfmt
fn format_generated_code(output_dir: &Path) -> Result<()> {
    let mut cmd = Command::new("rustfmt");
    cmd.arg("--edition").arg("2024");
    cmd.arg(output_dir.join("*.rs"));

    match cmd.output() {
        Ok(output) => {
            if output.status.success() {
                println!("{} Code formatted successfully", "✓".green());
            } else {
                println!("{} rustfmt reported issues", "⚠".yellow());
            }
        }
        Err(_) => {
            println!("{} rustfmt not available, skipping formatting", "⚠".yellow());
        }
    }

    Ok(())
}
